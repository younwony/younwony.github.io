# Clean Code 스터디

> **블로그 원문**: https://youn12.tistory.com/category/Study/CleanCode
> **스터디 기간**: 2022년 6월 27일 ~ 2022년 8월 17일
> **참여자**: 통요, wony

---

## 스터디 개요

Robert C. Martin의 **"Clean Code"** 책을 함께 읽고 정리한 스터디입니다.

### 선정 이유
> "깨끗한 코드를 작성하기 위해"

### 진행 방식
- 매주 정해진 분량을 읽고 요약 발표
- 온라인 미팅
- 4주 + α 일정으로 진행

---

## 목차

0. [계획](#0-계획)
1. [깨끗한 코드](#1-깨끗한-코드)
2. [의미 있는 이름](#2-의미-있는-이름)
3. [함수](#3-함수)
4. [주석](#4-주석)
5. [형식 맞추기](#5-형식-맞추기)
6. [객체와 자료구조](#6-객체와-자료구조)
7. [오류 처리](#7-오류-처리)
8. [경계](#8-경계)
9. [단위 테스트](#9-단위-테스트)
10. [클래스](#10-클래스)
11. [시스템](#11-시스템)
12. [창발성](#12-창발성)
13. [동시성](#13-동시성)
14. [점진적인 개선](#14-점진적인-개선)
15. [JUnit 들여다보기](#15-junit-들여다보기)
16. [SerialDate 리펙터링](#16-serialdate-리펙터링)
17. [냄새와 휴리스틱](#17-냄새와-휴리스틱)
18. [회고](#18-회고)

---

## 0. 계획

**작성일**: 2022.06.24

### 책 소개
Clean Code는 "애자일 소프트웨어 장인 정신을 가르치는 책"으로, 깨끗한 코드를 작성하는 방법과 소프트웨어 장인 정신을 심어줍니다.

### 일정
- **1주차** (6/27 ~ 7/8): 1-4장
- **2주차** (7/11 ~ 7/15): 5-9장
- **3주차** (7/18 ~ 7/22): 10-13장
- **4주차** (7/25 ~ 7/29): 14-17장

---

## 1. 깨끗한 코드

**작성일**: 2022.06.28

### 5S 원칙
프로그래밍에도 적용되는 5S 원칙:
- **정리** (Seiri): 적절한 명명법
- **정돈** (Seiton): 코드가 있어야 할 위치
- **청소** (Seiso): 주석과 불필요한 코드 제거
- **청결** (Seiketsu): 표준화된 스타일
- **생활화** (Shitsuke): 규칙 준수 습관화

### 르블랑의 법칙
> "나중은 결코 오지 않는다"

기한을 맞추는 유일한 방법은 **언제나 코드를 최대한 깨끗하게 유지**하는 습관입니다.

### 깨끗한 코드의 특징
- 세세한 사항까지 꼼꼼하게 처리
- 한 가지에 집중
- 다른 사람도 읽기 쉬움
- 단위 및 인수 테스트 존재
- 의미 있는 이름 사용

### 단순 코드 규칙 (중요도 순)
1. 모든 테스트 통과
2. 중복 제거
3. 설계 아이디어 표현
4. 클래스/메서드/함수 최소화

### 핵심 기법
- **메서드 추출 (Extract Method)**: 여러 기능을 수행하는 메서드를 기능별로 분리
- **추상화**: 추상 메서드나 추상 클래스로 구현을 감싸 유연성 확보
- **보이스카우트 규칙**: "캠프장은 처음보다 더 깨끗하게 해 놓고 떠나라"

---

## 2. 의미 있는 이름

**작성일**: 2022.06.28

### 핵심 규칙들

#### 1. 의도를 분명히 밝혀라
변수, 함수, 클래스명은 **"존재 이유, 수행 기능, 사용 방법"**에 답해야 합니다.

```java
// Bad
int d;

// Good
int elapsedTimeInDays;
```

> 주석이 필요하면 의도가 불명확하다는 신호입니다.

#### 2. 그릇된 정보를 피해라
```java
// Bad - 실제 List가 아니라면 사용 금지
List<Account> accountList;

// Good
List<Account> accounts;
```

#### 3. 의미 있게 구분하라
불용어(noise word) 추가를 피하세요.
- `NameString` vs `Name` - 실질적 차이 없음

#### 4. 발음하기 쉬운 이름 사용
```java
// Bad
Date genymdhms;

// Good
Date generationTimestamp;
```

#### 5. 클래스/객체 이름
- 명사나 명사구 사용 (Customer, WikiPage)
- 동사 금지

#### 6. 메서드 이름
- 동사나 동사구 사용 (postPayment, save)
- 접근자는 get/set/is 접두어 사용

#### 7. 해법/문제 영역 이름
> "기술 개념에는 기술 이름이 가장 적합"

Visitor 패턴처럼 기술 용어를 활용하되, 적절한 용어가 없으면 문제 영역에서 가져옵니다.

---

## 3. 함수

**작성일**: 2022.07.01

### 핵심 원칙들

#### 작게 만들어라!
> "Make functions small!"

함수는 최소한의 중첩(최대 1-2 들여쓰기)으로 가독성을 높여야 합니다.

#### 한 가지만 해라!
함수는 한 가지를 잘 해야 하며, 관심사를 섞지 않아야 합니다.

#### 위에서 아래로 읽히게
코드는 내러티브처럼 흘러가야 하며, 위에서 아래로 추상화 수준이 낮아져야 합니다.

#### 서술적인 이름
긴 명확한 이름이 긴 주석보다 낫습니다.

### 함수 인수

#### 이상적인 인수 개수
0개 > 1개 > 2개 > 3개 이상은 피하라

#### 플래그 인수 금지
플래그 인수는 단일 책임 원칙을 위반합니다.

#### 매개변수 객체 사용
2-3개 인수가 필요하면 객체로 묶으세요.
```java
// Bad
void drawCircle(int x, int y, int radius);

// Good
void drawCircle(Point center, int radius);
```

### 오류 처리

#### 오류 코드보다 예외
오류 코드 열거형은 "의존성 자석"입니다. 예외를 사용하면 새 오류 유형 추가 시 재컴파일이 불필요합니다.

#### Try/Catch 블록 분리
오류 처리는 별도 함수로 추출하세요.

### 기타 지침
- 부수 효과 제거
- 명령과 질의 분리
- 출력 인수 대신 객체 상태 변경
- 상속과 추상화로 중복 제거

> "프로그래밍은 스토리텔링이다. 함수는 '동사', 클래스는 '명사'"

---

## 4. 주석

**작성일**: 2022.07.11

### 핵심 원칙
> "주석을 가능한 줄이도록 꾸준히 노력한다"

코드 자체가 의도를 명확히 표현할 수 있다면 주석은 불필요합니다.

### 좋은 주석의 예시

#### 법적 주석
저작권이나 라이선스 정보

#### TODO 주석
앞으로 구현해야 할 작업 (정기적으로 제거 필요)

#### 복잡한 알고리즘 설명
"왜 이 방식을 선택했는가"를 설명하는 주석

### 나쁜 주석 목록
- 중복되거나 주절거리는 주석
- 오해의 여지가 있는 주석
- 의무적 주석
- 코드 이력을 기록하는 주석
- 있으나 마나한 주석

### 결론
> 정말 좋은 주석은 **주석을 달지 않는 방법**

---

## 5. 형식 맞추기

**작성일**: 2022.07.13

### 핵심 개념
> "코드 형식은 의사소통의 일환"

구현 코드는 변하지만, **"개발자의 스타일과 규율은 사라지지 않는다"**

### 신문 기사 구조
- 최상단: 고차원 개념과 알고리즘
- 중간: 세부 내용
- 하단: 저차원 함수와 세부 내역

### 세로 형식
- 빈 행으로 개념 분리
- 밀접한 코드는 가까이 배치
- 변수는 사용 위치 근처에 선언
- 인스턴스 변수는 클래스 맨 처음
- 호출 함수를 호출되는 함수보다 먼저 배치

### 가로 형식
- 행길이 제한 (저자는 120자 기준)
- 공백으로 밀접/느슨한 개념 구분

### 팀 규칙
> "팀에 속한다면 자신이 선호해야 할 규칙은 팀 규칙"

개인의 스타일보다 일관성을 우선해야 합니다.

---

## 6. 객체와 자료구조

**작성일**: 2022.07.14

### 핵심 주제
변수를 비공개로 정의하면서도 get/set 함수를 공개하는 모순을 다룹니다.

### 자료 추상화
> "get/set 함수만으로는 클래스가 되지 않는다"

추상 인터페이스를 통해 사용자가 구현을 모른 채 핵심을 조작할 수 있어야 합니다.

### 객체/자료구조 비대칭

| 구분 | 객체 | 자료구조 |
|------|------|----------|
| 특징 | 함수 공개, 자료 숨김 | 자료 노출, 함수 미제공 |
| 장점 | 새 클래스 추가 용이 | 새 함수 추가 용이 |

- 새로운 타입이 필요하면 → 객체지향
- 새로운 함수가 필요하면 → 절차적 코드

### 디미터 법칙
> "모듈은 조작하는 객체의 속사정을 몰라야 한다"

기차 충돌 코드(연쇄된 메서드 호출)를 피하세요.

### 잡종 구조
객체와 자료구조가 섞인 구조는 **"양쪽의 단점만 모아놓게"** 되므로 피해야 합니다.

### DTO/활성 레코드
자료 전달 객체는 자료구조로 취급하되, 비즈니스 규칙은 별도 객체에서 처리해야 합니다.

---

## 7. 오류 처리

**작성일**: 2022.07.16

### 핵심 원칙들

#### 1. 예외 사용 선호
오류 코드와 if/else 문보다 try/catch를 통한 예외 처리가 더 깔끔합니다.

#### 2. Try-Catch-Finally부터 작성
> "try 블록은 트랜잭션과 비슷하다"

예외 발생 코드 작성 시 먼저 try-catch-finally로 시작하면 안정적입니다.

#### 3. Unchecked 예외 사용
Checked 예외는 OCP를 위반하고 캡슐화를 깨뜨립니다.

#### 4. 의미 있는 예외 정보
오류 메시지에 실패한 연산, 실패 유형 등 충분한 정보를 담아야 합니다.

#### 5. Wrapper 패턴 활용
외부 API의 다양한 예외들을 하나의 예외로 변환하면 의존성이 줄어듭니다.

#### 6. Null 회피
null 반환/전달 대신 예외 발생이나 특수 사례 객체(`Collections.emptyList()`)를 사용하세요.

### 결론
> "깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다"

---

## 8. 경계

**작성일**: 2022.07.16

### 개요
> "시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다"

패키지, 오픈소스, 사내 컴포넌트 등을 깔끔하게 통합하는 기법을 설명합니다.

### 핵심 내용

#### 1. 외부 코드 사용하기
경계 인터페이스를 공개 API로 직접 넘기면 인터페이스 변경 시 수정할 코드가 많아집니다.

**해결책**: 경계 인터페이스를 클래스 안으로 숨겨 객체 유형을 관리하세요.

#### 2. 경계 살피고 익히기
외부 API를 신뢰하지 말고 **학습 테스트**를 작성하세요.

#### 3. 학습 테스트의 가치
> "필요한 지식만 확보하는 손쉬운 방법"

패키지 업그레이드 시 경계 테스트가 있으면 이전이 수월합니다.

#### 4. 미존재 코드 사용하기
모르는 코드와 아는 코드를 분리하여 **Adapter 패턴**으로 API 사용을 캡슐화합니다.

#### 5. 깨끗한 경계
- 변경이 대표적인 경계에서는 코드를 깔끔히 분리
- 테스트 케이스로 기대치 정의
- 외부 코드보다 우리 코드에 의존
- 새로운 클래스로 감싸거나 Adapter 패턴 사용

---

## 9. 단위 테스트

**작성일**: 2022.07.17

### TDD의 세 가지 법칙
1. 실패하는 테스트를 먼저 작성한 후 실제 코드 작성
2. 컴파일만 실패하도록 최소한의 테스트 작성
3. "테스트를 통과할 정도로만 실제 코드를 작성"

### 깨끗한 테스트 코드의 중요성
> "지저분한 테스트 코드를 짜는 건 짜지 않는 것보다 더 못하다"

테스트 코드가 유지되지 않으면 실제 코드도 점점 악화됩니다.

### 테스트의 가치
테스트 케이스가 존재하면 개발자는 변경을 두려워하지 않습니다.

### F.I.R.S.T 원칙
- **F**ast: 빠른 실행 속도
- **I**ndependent: 테스트 간 독립성
- **R**epeatable: 모든 환경에서 반복 가능
- **S**elf-Validating: 명확한 성공/실패 판정
- **T**imely: 실제 코드 작성 전에 작성

> "테스트 코드를 깨끗이 유지하자"

---

## 10. 클래스

**작성일**: 2022.08.01

### 클래스 구조
표준 Java 관례에 따른 순서:
1. static public 변수
2. static private 변수
3. private 인스턴스 변수
4. public 함수
5. private 함수 (호출하는 public 함수 다음에 배치)

### 캡슐화
> "변수와 유틸리티 함수는 가급적 공개하지 않는 것이 좋다"

테스트를 위해 protected 접근이 필요할 때도 있지만, 캡슐화를 풀어주는 것은 최후의 수단입니다.

### 클래스 크기
함수는 줄 수로 측정하지만, 클래스 크기는 **"맡은 책임의 수"**로 결정됩니다.

### 단일 책임 원칙 (SRP)
> "클래스는 변경해야 할 이유가 하나뿐이어야 한다"

작은 클래스 여러 개가 큰 클래스 하나보다 낫습니다.

### 응집도
메서드가 여러 인스턴스 변수를 사용해야 높은 응집도를 유지합니다. 특정 변수가 일부 메서드에서만 사용되면 새 클래스 추출을 고려하세요.

### 변경으로부터 격리
결합도를 줄이고 구체 구현보다 추상화에 의존하면 시스템이 유연해집니다 (의존성 역전 원칙).

---

## 11. 시스템

**작성일**: 2022.08.04

### 핵심 주제
높은 추상화 수준에서 깨끗한 시스템 설계 원칙을 다룹니다.

> 도시처럼 소프트웨어도 "각자의 역할에 맞는 팀"이 필요합니다.

### 1. 시스템 제작과 사용의 분리
초기화 지연 기법의 한계:
- 의존성 증가
- 테스트 어려움
- 단일책임원칙 위배

**해결책**:
- Main 분리
- 팩토리 패턴
- 의존성 주입(DI)

### 2. 확장성
반복적 애자일 방식으로 점진적 발전 가능합니다.
> "관심사를 적절히 분리"하면 아키텍처가 진화할 수 있습니다.

### 3. 횡단 관심사
AOP(Aspect-Oriented Programming)로 영속성, 보안 등을 분리하여 핵심 로직에 영향 없이 처리합니다.

### 4. 테스트 주도 아키텍처
POJO 객체 기반 모듈화와 관점 활용으로 진정한 테스트 주도 설계가 가능합니다.

### 5. 기타 원칙
- 최선의 결정은 "마지막 순간까지 미루기"로 정보수집 후 진행
- 표준은 고객 가치 위에 있어야 함
- 도메인 특화 언어(DSL)로 의사소통 간극 축소

---

## 12. 창발성

**작성일**: 2022.08.04

### Kent Beck의 4가지 단순 설계 규칙 (우선순위 순)

1. **모든 테스트를 실행한다** (최고 우선순위)
2. **중복을 없앤다**
3. **프로그래머 의도를 표현한다**
4. **클래스와 메서드 수를 최소로 줄인다** (최저 우선순위)

### 규칙 1: 테스트 실행
> "검증이 불가능한 시스템은 절대 출시하면 안 된다"

테스트 가능성이 SRP 준수와 낮은 결합도를 자동으로 유도합니다.

### 규칙 2~4: 리팩터링
테스트 케이스 작성 후 점진적으로 설계 품질을 개선합니다.
- 응집도 향상
- 결합도 감소
- 관심사 분리

### 규칙 3: 표현성
- 좋은 이름 선택
- 함수·클래스 크기 축소
- 표준 디자인 패턴 활용
- 단위 테스트를 문서처럼 작성

### 규칙 4: 최소화
극단적 적용 피하기

---

## 13. 동시성

**작성일**: 2022.08.10

### 핵심 개념
> 동시성의 정의: "무엇"과 "언제"를 분리하는 전략

### 동시성의 미신과 진실

**잘못된 인식**:
- 동시성이 항상 성능을 높인다
- 설계가 변하지 않는다
- 컨테이너를 사용하면 이해할 필요가 없다

**올바른 인식**:
> "동시성은 다소 부하를 유발하며, 복잡하고, 버그 재현이 어렵습니다"

### 동시성 방어 원칙
1. **단일 책임 원칙(SRP)**: 동시성 코드는 별도로 분리
2. **자료 범위 제한**: 공유 자료 최소화, `synchronized` 활용
3. **자료 사본 사용**: 원본 대신 읽기 전용 복사본 활용
4. **독립적 스레드**: 각 스레드는 고유 데이터로 독립 운영

### 주요 개념
- **한정된 자원**: DB 연결, 버퍼 등 제한된 리소스
- **상호 배제**: 한 번에 한 스레드만 접근
- **기아 상태**: 스레드가 자원을 영원히 기다림
- **데드락**: "여러 스레드가 서로 끝나기를 기다린다"
- **라이브락**: 스레드들이 상호 간섭으로 진행 불가

### 실행 모델
- **생산자-소비자**: 대기열을 통한 정보 교환
- **읽기-쓰기**: 공유자원의 읽기/쓰기 균형 관리

### 구현 지침
1. 동기화 최소화 (임계 영역을 최대한 작게)
2. 종료 코드는 개발 초기부터 구현
3. 다양한 환경에서 테스트
4. 보조 코드 삽입으로 오류 유발 테스트
5. 순차 코드부터 검증 (POJO)

---

## 14. 점진적인 개선

**작성일**: 2022.08.10

### 핵심 원칙
> "프로그래밍은 과학보다 공예에 가깝다"

> "깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 한다"

단순히 동작하는 코드만으로는 부족합니다. 전문가 정신이 필요합니다.

### 개선 시 주의사항
큰 구조 변경은 프로그램을 망칠 수 있으며, 일부는 회복 불가능한 상태에 빠질 수 있습니다.

### 해결 방법: TDD
> "언제 어느 때라도 시스템이 돌아가야 한다"

변경 전후 동일한 동작을 보장하기 위해:
- 단위 테스트: JUnit 사용
- 인수 테스트: FitNess 위키 활용

### 핵심 교훈
즉각적인 정리가 중요합니다. 시간이 지날수록 개선 비용이 증가합니다.

---

## 15. JUnit 들여다보기

**작성일**: 2022.08.11

### 핵심 메시지
> "JUnit은 자바 프레임워크 중 가장 유명하다. 개념은 단순하며 정의는 정밀하고 구현은 우아하다"

이 장은 코드 예제로 구성되어 있으며, 실제 프레임워크 구현을 분석합니다.

### 보이스카우트 규칙
> "캠프장은 처음 왔을 때보다 더 깨끗하게 해 놓고 떠나라"

코드 개선은 지속적인 책임입니다.

### 저자의 통찰
- 주어진 기능 개발뿐 아니라 주변 코드의 개선도 함께 고려
- 완벽한 모듈도 지속적 개선 필요
- 코드 품질 향상은 모든 개발자의 책임

---

## 16. SerialDate 리펙터링

**작성일**: 2022.08.14

### 핵심 내용
Date 클래스인 SerialDate를 분석하고 테스트 케이스 부족 문제와 리팩터링 과정을 다룹니다.

### Boy Scout Rule
> "check in code cleaner than when you checked it out"

시간 투자에도 불구하고 다음과 같은 가치가 있었습니다:
- 테스트 커버리지 증가
- 버그 수정
- 코드 크기 감소
- 코드 명확성 향상

---

## 17. 냄새와 휴리스틱

**작성일**: 2022.08.15

마틴 파울러의 "Refactoring"에서 논의한 코드 냄새와 저자가 추가한 휴리스틱을 정리합니다.

### 주석(Comments) - C1~C5
- 버전 관리 시스템에 속한 정보를 주석으로 남기지 말 것
- 불필요하거나 잘못된 주석은 제거
- 주석 처리된 코드는 즉시 삭제

### 환경(Environment) - E1~E2
- 빌드는 한 단계로 끝나야 함
- 모든 단위 테스트는 한 명령으로 실행 가능해야 함

### 함수(Functions) - F1~F4
- 함수 인수 개수 최소화
- 출력 인수 피하기
- 함수는 한 가지 기능만 수행
- 호출되지 않는 함수는 삭제

### 일반(General) - G1~G36

**G5: 중복 (DRY 원칙)**
> "이 책에 나오는 가장 중요한 규칙 중 하나"

중복은 추상화 기회로 봐야 합니다.

**G6: 추상화 수준**
저차원 개념은 파생 클래스에, 고차원 개념은 기초 클래스에 배치

**G23: 다형성**
Switch/Case 문보다 다형성 활용을 우선

**G36: 추이적 탐색 회피**
디미터 법칙(Demeter's Law)을 따를 것

### 자바(Java) - J1~J3
- Wildcard import 권장 (결합도 감소)
- 상수 상속 금지, static import 사용
- int 상수 대신 Enum 활용

### 이름(Names) - N1~N7
> "소프트웨어의 가독성의 90%는 이름이 결정"

- 구현을 드러내는 이름 피하기
- 표준 명명법 사용
- 이름 길이는 범위에 비례
- 헝가리안 표기법 피하기

### 테스트(Testing) - T1~T9
- 깨질 만한 모든 부분을 검증
- 커버리지 도구 활용
- 경계 조건 철저히 테스트
- 버그 주변 코드 집중 테스트
- 느린 테스트는 실행되지 않음

### 결론
> "목록을 따른다고 깨끗한 코드가 나오지 않는다. 전문가 정신과 장인 정신은 가치에서 나온다"

---

## 18. 회고

**작성일**: 2022.08.17

### 좋았던 점
- 오랜 시간 후 재개한 스터디라 흥미롭게 진행
- 기술서적이 아니라서 부담 없이 읽을 수 있었음

### 배운 점
> "깨끗한 코드를 작성하는 방법에 대해 알 수 있었다"

코드 품질에 대한 궁금증의 실마리를 찾음

### 부족했던 점
- 구체적인 일정 계획 없이 진행되어 예상보다 길어짐
- 책 내용을 완전히 이해하지 못함
- 이론 학습에만 그쳐 실제 적용(체화)이 부족함

### 향후 계획
- 다음 스터디는 구체적 일정 설정
- 더 심화된 진행 고려

---

**참여자**: 통요, wony
