# Clean Code 완벽 정리

> **원서**: Clean Code: A Handbook of Agile Software Craftsmanship
> **저자**: Robert C. Martin (Uncle Bob)
> **학습 기간**: 2022년 스터디
> **포스팅 수**: 19개

---

## 📚 목차

1. [2장 - 의미 있는 이름](#2장---의미-있는-이름)
2. [3장 - 함수](#3장---함수)
3. [4장 - 주석](#4장---주석)
4. [5장 - 형식 맞추기](#5장---형식-맞추기)
5. [6장 - 객체와 자료구조](#6장---객체와-자료구조)
6. [7장 - 오류 처리](#7장---오류-처리)
7. [8장 - 경계](#8장---경계)
8. [9장 - 단위 테스트](#9장---단위-테스트)
9. [10장 - 클래스](#10장---클래스)
10. [11장 - 시스템](#11장---시스템)
11. [12장 - 창발성](#12장---창발성)
12. [13장 - 동시성](#13장---동시성)
13. [14장 - 점진적인 개선](#14장---점진적인-개선)
14. [15장 - JUnit 들여다보기](#15장---junit-들여다보기)
15. [16장 - SerialDate 리팩터링](#16장---serialdate-리팩터링)
16. [17장 - 냄새와 휴리스틱](#17장---냄새와-휴리스틱)
17. [회고](#학습-회고)

---

## 2장 - 의미 있는 이름

### 핵심 원칙
- **의도를 분명히 밝혀라**: 변수/함수/클래스명만 보고도 의도를 알 수 있어야 함
- **그릇된 정보를 피하라**: 약어, 유사한 이름 지양
- **의미 있게 구분하라**: a1, a2 같은 연속된 숫자 금지
- **발음하기 쉬운 이름을 사용하라**: genymdhms → generationTimestamp
- **검색하기 쉬운 이름을 사용하라**: 한 글자 변수 지양

### 네이밍 규칙
```java
// ❌ 나쁜 예
int d; // elapsed time in days

// ✅ 좋은 예
int elapsedTimeInDays;
int daysSinceCreation;
int fileAgeInDays;
```

### 클래스명 vs 메서드명
- **클래스명**: 명사나 명사구 (Customer, WikiPage, Account)
- **메서드명**: 동사나 동사구 (postPayment, deletePage, save)

---

## 3장 - 함수

### 핵심 원칙
1. **작게 만들어라**: 함수는 20줄 이내가 이상적
2. **한 가지만 해라**: 함수는 한 가지 작업만 수행해야 함
3. **함수 당 추상화 수준은 하나로**: 고수준/중간수준/저수준 개념 혼합 금지

### Switch 문
- 다형성을 이용하여 switch 문을 저수준 클래스에 숨김
- 팩토리 패턴 활용

### 서술적인 이름 사용
```java
// ❌ 나쁜 예
public void process() { ... }

// ✅ 좋은 예
public void includeSetupAndTeardownPages() { ... }
```

### 함수 인수
- **이상적**: 0개 (무항)
- **최선**: 1개 (단항)
- **차선**: 2개 (이항)
- **회피**: 3개 이상 (삼항 이상)

### 부수 효과를 일으키지 마라
- 함수명이 암시하지 않는 일을 하지 말 것
- 시간적 결합(temporal coupling) 주의

---

## 4장 - 주석

### 좋은 주석
1. **법적인 주석**: 저작권, 라이선스 정보
2. **정보를 제공하는 주석**: 정규표현식 설명 등
3. **의도를 설명하는 주석**: 왜 이렇게 구현했는지
4. **TODO 주석**: 앞으로 할 일

### 나쁜 주석
1. **주절거리는 주석**: 불명확한 설명
2. **같은 이야기를 중복하는 주석**: 코드보다 읽기 어려운 주석
3. **오해할 여지가 있는 주석**: 잘못된 정보
4. **의무적으로 다는 주석**: JavaDoc 남용
5. **주석으로 처리한 코드**: 버전 관리 시스템 사용할 것

### 핵심 교훈
> "주석은 나쁜 코드를 보완하지 못한다. 코드로 의도를 표현하라!"

---

## 5장 - 형식 맞추기

### 코드 형식의 목적
- 의사소통의 일환
- 가독성과 일관성 확보
- 프로젝트 전체의 통일성

### 세로 형식
- **적정 파일 크기**: 200~500줄 (최대 500줄)
- **신문 기사처럼**: 위에서 아래로 읽혀야 함
- **개념은 빈 행으로 분리**: 패키지, import, 함수 사이

### 가로 형식
- **한 줄 길이**: 80~120자 권장
- **들여쓰기**: 일관된 규칙 적용
- **가로 공백**: 연산자, 인수 구분

---

## 6장 - 객체와 자료구조

### 자료 추상화
- **구현을 감춰라**: getter/setter 남발 지양
- **의미 있는 추상화 제공**: 구현체가 아닌 추상 인터페이스 노출

### 객체 vs 자료구조
| 구분 | 객체 | 자료구조 |
|------|------|----------|
| 목적 | 기능 제공 | 데이터 노출 |
| 추상화 | 높음 | 낮음 |
| 변경 | 기능 추가 쉬움 | 자료형 추가 쉬움 |

### 디미터 법칙 (Law of Demeter)
- "낯선 사람과 대화하지 마라"
- 메서드 체이닝 남용 금지

```java
// ❌ 나쁜 예 (기차 충돌)
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();

// ✅ 좋은 예
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

---

## 7장 - 오류 처리

### 예외 사용의 원칙
1. **오류 코드보다 예외 사용**: 비즈니스 로직과 오류 처리 분리
2. **Try-Catch-Finally 문부터 작성**: 예외 범위 정의
3. **Unchecked 예외 사용**: Checked 예외는 OCP 위반

### 예외에 의미 제공
- 예외 메시지에 충분한 정보 포함
- 로깅 목적 고려

### null 반환/전달 금지
```java
// ❌ 나쁜 예
public List<Employee> getEmployees() {
    if (/* 직원 없음 */) {
        return null;  // NullPointerException 위험
    }
}

// ✅ 좋은 예
public List<Employee> getEmployees() {
    if (/* 직원 없음 */) {
        return Collections.emptyList();  // 빈 리스트 반환
    }
}
```

---

## 8장 - 경계

### 외부 코드 사용하기
- **학습 테스트**: 외부 API 학습을 위한 테스트 작성
- **어댑터 패턴**: 외부 API를 우리 인터페이스로 감싸기

### 아직 존재하지 않는 코드
- **Fake 객체** 활용
- 인터페이스로 경계 정의

---

## 9장 - 단위 테스트

### TDD 법칙 3가지
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다

### F.I.R.S.T 원칙
- **Fast (빠르게)**: 테스트는 빨리 실행되어야 함
- **Independent (독립적으로)**: 테스트끼리 의존하면 안 됨
- **Repeatable (반복 가능하게)**: 어떤 환경에서도 반복 실행 가능
- **Self-Validating (자가검증)**: bool 값으로 결과 제공
- **Timely (적시에)**: 실제 코드 구현 직전에 작성

### 핵심 교훈
> "테스트 코드는 유연성, 유지보수성, 재사용성을 제공한다."

---

## 10장 - 클래스

### 클래스 체계
1. public static 상수
2. private static 변수
3. private 인스턴스 변수
4. public 함수
5. private 유틸리티 함수

### 단일 책임 원칙 (SRP)
- 클래스는 변경할 이유가 단 하나여야 함
- 책임(변경 이유)을 기준으로 클래스 분리

### 응집도 (Cohesion)
- 클래스 변수를 많은 메서드가 사용할수록 응집도 높음
- 응집도가 높은 클래스 = 좋은 클래스

### 변경으로부터 격리
- 추상화를 통한 상세 구현 격리
- DIP (Dependency Inversion Principle) 준수

---

## 11장 - 시스템

### 관심사 분리
- **시스템 생성과 사용을 분리하라**
- Main 분리, 팩토리 패턴, 의존성 주입

### 확장
- 시스템은 처음부터 올바르게 만들 수 없음
- 점진적 확장이 가능한 설계

### 횡단 관심사 (Cross-Cutting Concerns)
- AOP (Aspect-Oriented Programming) 활용
- 트랜잭션, 보안, 로깅 등

---

## 12장 - 창발성

### 우수한 설계의 4가지 규칙
1. **모든 테스트를 실행한다**: 테스트 가능한 시스템
2. **중복을 없앤다**: DRY 원칙
3. **프로그래머 의도를 표현한다**: 명확한 네이밍, 작은 함수/클래스
4. **클래스와 메서드 수를 최소로 줄인다**: 실용주의

### SOLID 원칙 적용 용이
- 위 4가지 규칙을 따르면 자연스럽게 SOLID 원칙 준수

---

## 13장 - 동시성

### 동시성이 필요한 이유
- 결합(coupling)을 없애는 전략
- 처리량과 응답 시간 개선

### 동시성 방어 원칙
1. **단일 책임 원칙 (SRP)**: 동시성 코드 분리
2. **자료 범위 한정**: synchronized 최소화
3. **사본 사용**: 공유 자료 복사본으로 동기화 회피
4. **스레드는 독립적**: 공유 자료 최소화

### 동시성 테스트
- 말이 안 되는 실패도 잠정적 스레드 문제로 취급
- 다양한 설정과 환경에서 반복 테스트

---

## 14장 - 점진적인 개선

### 핵심 교훈
> "프로그래밍은 과학보다 **공예(craft)**에 가깝다."

### TDD를 통한 리팩터링
1. 테스트 작성
2. 코드 작성
3. 테스트 통과 확인
4. 리팩터링
5. 반복

### 점진적 개선 원칙
- 처음부터 완벽한 코드 불가능
- 작은 단위로 꾸준히 개선
- 항상 테스트 통과 유지

---

## 15장 - JUnit 들여다보기

### JUnit 프레임워크 특징
- **개념의 단순성**: 이해하기 쉬운 구조
- **정의의 정밀성**: 명확한 역할 분담
- **구현의 우아함**: 깔끔한 코드

### 점진적 개선 실천
- 코드를 처음보다 조금 더 깨끗하게
- 보이스카우트 규칙 적용

---

## 16장 - SerialDate 리팩터링

### 실전 리팩터링 과정
1. **테스트 커버리지 증가**: 50% → 92%
2. **버그 수정**: 발견된 버그 모두 수정
3. **코드 정리**: 불필요한 코드 제거, 네이밍 개선
4. **보이스카우트 규칙**: 코드를 더 깨끗하게

### 주요 개선사항
- Enum 활용
- 상수 정리
- 불필요한 주석 제거
- 메서드 분리 및 단순화

---

## 17장 - 냄새와 휴리스틱

### 주석 (Comments)
- **C1**: 부적절한 정보 - 메타 데이터는 주석 아님
- **C2**: 쓸모없는 주석
- **C3**: 중복된 주석
- **C4**: 주석 처리된 코드

### 환경 (Environment)
- **E1**: 여러 단계 빌드 - 한 명령으로 빌드
- **E2**: 여러 단계 테스트 - 한 명령으로 모든 테스트

### 함수 (Functions)
- **F1**: 너무 많은 인수
- **F2**: 출력 인수 - 반환 값 사용
- **F3**: 플래그 인수 - boolean 인수 금지
- **F4**: 죽은 함수 - 사용하지 않으면 삭제

### 일반 (General)
- **G1**: 한 소스 파일에 여러 언어
- **G2**: 당연한 동작을 구현하지 않음
- **G3**: 경계를 올바로 처리하지 않음
- **G4**: 안전 절차 무시
- **G5**: 중복 (DRY 위반)

### 이름 (Names)
- **N1**: 서술적인 이름 사용
- **N2**: 적절한 추상화 수준
- **N3**: 표준 명명법 사용
- **N4**: 명확한 이름

---

## 학습 회고

### 긍정적 평가
✅ **재미있었던 점**
- 실전 코드 리팩터링 과정 흥미로움
- JUnit, SerialDate 사례 학습 유익

✅ **가볍게 읽을 수 있었던 점**
- 번역서의 높은 완성도
- 실용적인 예제 중심

✅ **학습 성과**
- 깨끗한 코드 작성 방법 습득
- 코드 개선의 방향성 획득
- SOLID 원칙 이해도 향상

### 아쉬운 점
❌ **명확한 일정 부재**
- 스터디 진행 속도 불규칙

❌ **완벽한 이해 미흡**
- 일부 개념은 추가 학습 필요

❌ **체화 부족**
- 실무 적용 연습 부족
- 반복 학습 필요

---

## 핵심 원칙 정리

### 1. 보이스카우트 규칙
> "캠프장을 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라."

코드도 마찬가지. 체크아웃할 때보다 체크인할 때 더 깨끗하게!

### 2. 프로그래밍은 공예
> "프로그래밍은 과학보다 공예에 가깝다."

처음부터 완벽한 코드 불가능. 점진적 개선이 핵심.

### 3. 테스트의 중요성
> "테스트 코드는 유연성, 유지보수성, 재사용성을 제공한다."

테스트 없는 코드는 레거시 코드!

### 4. 코드로 의도 표현
> "주석은 나쁜 코드를 보완하지 못한다."

주석 쓸 시간에 코드 개선!

---

## 실무 적용 가이드

### 즉시 적용 가능
1. ✅ 의미 있는 변수명 사용
2. ✅ 함수 20줄 이내로 작게 만들기
3. ✅ 한 함수는 한 가지 일만
4. ✅ null 반환 대신 빈 컬렉션 반환
5. ✅ 주석 처리된 코드 삭제

### 팀 단위 적용
1. 📋 코드 리뷰 시 Clean Code 기준 적용
2. 📋 공통 네이밍 규칙 수립
3. 📋 테스트 커버리지 목표 설정
4. 📋 리팩터링 시간 확보

### 장기 프로젝트
1. 🎯 레거시 코드 점진적 개선
2. 🎯 TDD 도입
3. 🎯 아키텍처 개선 (관심사 분리)
4. 🎯 SOLID 원칙 체화

---

## 참고 자료

- **원서**: Clean Code: A Handbook of Agile Software Craftsmanship
- **저자**: Robert C. Martin
- **출판사**: Prentice Hall (2008)
- **원본 블로그**: [youn12.tistory.com/category/Study/CleanCode](https://youn12.tistory.com/category/Study/CleanCode)

---

**작성일**: 2025-11-30
**기반**: 12Dev 블로그 Clean Code 19개 포스팅
