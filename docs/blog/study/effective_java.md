# Effective Java 3/E 스터디

> **블로그 원문**: https://youn12.tistory.com/category/Study/Effective%20Java
> **스터디 기간**: 2023년 4월 ~ 5월
> **책 정보**: Joshua Bloch, Effective Java 3rd Edition

---

## 스터디 개요

Joshua Bloch의 **"Effective Java 3판"**을 읽고 정리한 스터디입니다.

### 책의 핵심 원칙
1. **명료성** - 코드는 명확해야 함
2. **단순성** - 불필요한 복잡성 제거
3. **예측 가능한 동작** - "컴포넌트는 사용자를 놀라게 하는 동작을 해서는 절대 안 된다"
4. **적절한 크기** - 너무 크지도, 너무 작지도 않은 컴포넌트
5. **코드 재사용** - 복사가 아닌 재사용 권장
6. **낮은 의존성** - 컴포넌트 간 결합도 최소화
7. **빠른 오류 감지** - 컴파일 시점에 오류 포착

> 이러한 규칙이 절대적이지 않지만, 어길 경우 합당한 이유가 필요합니다.

---

## 목차

1. [1장 들어가기](#1장-들어가기)
2. [2장 객체 생성과 파괴](#2장-객체-생성과-파괴)
3. [3장 모든 객체의 공통 메서드](#3장-모든-객체의-공통-메서드)
4. [4장 클래스와 인터페이스](#4장-클래스와-인터페이스)

---

## 1장 들어가기

**작성일**: 2023.04.18

책의 핵심 규칙들과 철학을 소개하는 장입니다.

### 핵심 메시지
코드는 명료하고 단순해야 하며, 예측 가능한 동작을 해야 합니다. 오류는 가능한 한 컴파일 시점에 잡아야 합니다.

---

## 2장 객체 생성과 파괴

**작성일**: 2023.04.30

9개의 아이템을 통해 객체 생성과 파괴에 대한 모범 사례를 다룹니다.

### 아이템 1: 정적 팩터리 메서드를 고려하라

생성자 대신 정적 팩터리 메서드를 고려해야 하는 이유:
- 명명의 자유로움 (이름으로 의미 전달)
- 인스턴스 통제 가능
- 하위 타입 반환 가능
- 입력 매개변수에 따라 다른 클래스 객체 반환 가능

**단점**: 생성자보다 찾기 어려움

### 아이템 2: 생성자에 매개변수가 많다면 빌더를 고려하라

많은 매개변수를 가진 클래스의 경우:
- 점층적 생성자 패턴 → 읽기 어려움
- 자바빈즈 패턴 → 일관성 문제
- **빌더 패턴** → 가독성과 안정성 모두 확보

### 아이템 3: private 생성자나 열거 타입으로 싱글턴임을 보증하라

싱글턴 보장 방법:
1. private 생성자 + public static final 필드
2. private 생성자 + 정적 팩터리 메서드
3. **열거 타입** (가장 견고, 리플렉션 및 직렬화 공격에 안전)

### 아이템 4: 인스턴스화를 막으려거든 private 생성자를 사용하라

정적 메서드와 정적 필드만 담은 유틸리티 클래스는 인스턴스화를 막아야 합니다.

```java
public class UtilityClass {
    private UtilityClass() {
        throw new AssertionError();
    }
}
```

### 아이템 5: 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

> "의존성을 하드코딩하지 말고 주입하라"

의존 객체 주입은:
- 유연성 향상
- 테스트 용이성 증가
- 재사용성 증가

### 아이템 6: 불필요한 객체 생성을 피하라

재사용 가능한 객체:
- 불변 객체
- 오토박싱 주의 (기본 타입 선호)
- 정규표현식 Pattern 캐싱

### 아이템 7: 다 쓴 객체 참조를 해제하라

메모리 누수 주의 케이스:
- 자체 메모리 관리 클래스 (스택, 캐시 등)
- 리스너나 콜백

**해결책**: 다 쓴 참조는 null로 설정

### 아이템 8: finalizer와 cleaner 사용을 피하라

예측 불가능하고 느림. 대안:
- **AutoCloseable** 구현
- **try-with-resources** 사용

### 아이템 9: try-finally보다는 try-with-resources를 사용하라

```java
// Good
try (InputStream in = new FileInputStream(src)) {
    // ...
}
```

자원 정리와 예외 억제를 적절히 처리합니다.

---

## 3장 모든 객체의 공통 메서드

**작성일**: 2023.05.07

Object 클래스의 재정의 가능한 메서드들에 대해 다룹니다.

### 아이템 10: equals는 일반 규약을 지켜 재정의하라

equals를 재정의하지 않아야 하는 경우:
1. 각 인스턴스가 본질적으로 고유한 경우
2. 논리적 동치성 검사가 불필요한 경우
3. 상위 클래스의 equals가 적절한 경우
4. private 클래스라 equals 호출이 없는 경우

재정의 시 5가지 규약:
- **반사성**: x.equals(x) == true
- **대칭성**: x.equals(y) == y.equals(x)
- **추이성**: x.equals(y) && y.equals(z) → x.equals(z)
- **일관성**: 일정하게 같은 결과
- **null-아님**: x.equals(null) == false

### 아이템 11: equals를 재정의하려거든 hashCode도 재정의하라

> 같은 객체는 같은 해시코드를 반환해야 합니다.

그렇지 않으면 HashMap이나 HashSet에서 문제가 발생합니다.

### 아이템 12: toString을 항상 재정의하라

> "모든 구체 클래스에서 Object의 toString을 재정의하자"

디버깅과 로깅에 유용합니다.

### 아이템 13: clone 재정의는 주의해서 진행하라

Cloneable 구현 시 주의사항:
- 가변 객체 참조 시 깊은 복사 필요
- **더 나은 대안**: 복사 생성자, 복사 팩터리

```java
public Yum(Yum yum) { ... }  // 복사 생성자
public static Yum newInstance(Yum yum) { ... }  // 복사 팩터리
```

### 아이템 14: Comparable을 구현할지 고려하라

순서가 명확한 값 클래스는 Comparable을 구현해야 합니다.

compareTo 규약:
- sgn(x.compareTo(y)) == -sgn(y.compareTo(x))
- 추이성 보장
- equals와 일관성 유지 권장

---

## 4장 클래스와 인터페이스

**작성일**: 2023.05.23

클래스와 인터페이스를 효과적으로 설계하는 11개 아이템을 다룹니다.

### 아이템 15: 클래스와 멤버의 접근 권한을 최소화하라

> "정보 은닉"은 소프트웨어 설계의 근본 원칙

- 모든 클래스와 멤버는 가능한 한 접근 불가능하게
- public 클래스는 가변 필드를 직접 노출하지 않음

### 아이템 16: public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

캡슐화를 위해 getter/setter 사용을 권장합니다.

단, package-private이나 private 중첩 클래스는 필드 노출 가능합니다.

### 아이템 17: 변경 가능성을 최소화하라

불변 클래스의 5가지 규칙:
1. setter를 제공하지 않음
2. 확장을 막음 (final 클래스 또는 private 생성자)
3. 모든 필드를 final로 선언
4. 모든 필드를 private으로 선언
5. 가변 컴포넌트에 대한 접근을 막음

```java
public final class Complex {
    private final double re;
    private final double im;
    // ...
}
```

### 아이템 18: 상속보다는 컴포지션을 사용하라

> 상속은 캡슐화를 깨뜨립니다.

래퍼 클래스(데코레이터 패턴)를 사용하여 기능을 확장하세요.

```java
public class InstrumentedSet<E> extends ForwardingSet<E> {
    private int addCount = 0;
    // ...
}
```

### 아이템 19: 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

상속용 클래스는:
- 내부 구현 세부사항을 문서화
- self-use 패턴 명시
- 생성자에서 재정의 가능 메서드 호출 금지

상속을 의도하지 않았다면 final 선언하거나 private 생성자를 사용하세요.

### 아이템 20: 추상 클래스보다는 인터페이스를 우선하라

인터페이스의 장점:
- 다중 상속 가능
- 믹스인 정의 가능
- 계층구조 없는 타입 프레임워크

골격 구현(skeletal implementation)을 함께 제공하면 좋습니다.

### 아이템 21: 인터페이스는 구현하는 쪽을 생각해 설계하라

디폴트 메서드 추가 시:
- 기존 구현체와의 호환성 고려
- 모든 상황에서 불변식을 해치지 않는지 확인

### 아이템 22: 인터페이스는 타입을 정의하는 용도로만 사용하라

> 상수 인터페이스 안티패턴을 피하세요.

```java
// Bad - 상수 인터페이스
public interface Constants {
    double PI = 3.14159;
}

// Good - 상수 유틸리티 클래스
public final class Constants {
    private Constants() { }
    public static final double PI = 3.14159;
}
```

### 아이템 23: 태그 달린 클래스보다는 클래스 계층구조를 활용하라

태그 필드로 여러 타입을 구분하는 클래스는:
- 장황하고 오류 발생 가능성 높음
- 클래스 계층구조로 대체하세요

### 아이템 24: 멤버 클래스는 되도록 static으로 만들라

중첩 클래스 종류:
1. **정적 멤버 클래스** - 바깥 인스턴스 참조 불필요 시
2. **비정적 멤버 클래스** - 바깥 인스턴스 참조 필요 시
3. **익명 클래스** - 즉석에서 작은 함수 객체나 처리 객체
4. **지역 클래스** - 메서드 안에서 정의

멤버 클래스가 바깥 인스턴스에 접근할 필요가 없다면 static을 붙이세요.

### 아이템 25: 톱레벨 클래스는 한 파일에 하나만 담으라

한 파일에 여러 톱레벨 클래스를 선언하면 컴파일 순서에 따라 결과가 달라질 수 있습니다.

---

**참고**: 이 스터디는 4장까지 진행되었습니다.
